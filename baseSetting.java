/** 목표
 *  1.회원가입(주소API 연동, 이메일 인증, AJAX 통한 아이디 중복검사)
 *  2.관리자 페이지(인터셉터 적용, 상품관리, 회원관리)
 *  3.업로드(이미지 등록, 수정, 삭제)
 *  4.검색(&페이징)
 *  5.구매(장바구니, 포인트 사용)
 *  6.댓글(등록, 수정, 삭제)
 * 
 *  사용 환경
 *  -STS 3.9.9
 *  -Java SE 8 U21
 *  -Apache Tomcat8.5
 *  -Oracle DB & MySQL
 *  -MyBatis
 *  -Log4jdbc-log4j2
 */

 /** 패키지 추가 및 설정
  *  src/main/java 패키지 3개를 추가
  *  com.vam.model : VO(Value Object)패키지, 데이터 타입을 저장한다.
  *  com.vam.mapper : DAO(Data Access Object) 역할을 하는 패키지이다. 데이터베이스 접속하는 역할
                        또한 쿼리를 실행시켜주는 메서드를 가진다.
  *  com.vam.service : Service 패키지이다. mapper와 Controller 사이를 연결해주는 역할
                        Service는 비즈니스 로직을 수행하는 메서드를 가집니다.
                        (비즈니스 로직이란 업무에 필요한 데이터처리를 수행하는 응용프로그램의 일부)
     Mapper XML 저장 위치 폴더 생성
  *  src/main/resources 위치에 mapper 패키지명(com.vam.mapper)을 폴더 경로로 만들어준다.
  *  해당 경로에 mapper로 사용할 xml파일을 저장시킨다.
     
  *  생성한 패키지가 스프링에서 인식이 되도록 root-context.xml파일을 수정한다.
        -mapper 패키지는 MyBatis가 인식할 수 있도록 <mybatis-spring:scan> 태그를 추가해준다.
  *  model, service 패키지는 스프링이 인식할 수 있도록 <context:component-scan> 태그를 추가해준다.
     Servlet 버전 변경
  * java 설정등을 이용하기 위해선 servlet3.0이상 버전을 사용해야한다.
        -pom.xml에서 기존 servlet2.5 버전을 주석 처리 혹은 삭제 후 3.1.0 버전을 추가한다.

        핵심은 Mapper는 쿼리를 실행시키는 역할이란점과 Service는 비즈니스 로직을 실행하는 역할을 한다는 점이다.
        이번 포스팅 member Join을 설명해보면 Controller에서는 전달받은 데이터를 회원DB에 등고시키는 처리를하는
        Service 단계의 memberJoin()메서드를 호출하였고, Service 단계의 memberJoin() 메서드는 회원가입 쿼리를
        실행하는 Mapper단계의 memberJoin()메서드를 수행하고 있습니다.
  */

 /** 회원가입 기능 구현
  *  1.회원가입페이지(join.jsp)에서 필요 정보를 입력
  *  2.입력 후 '가입하기' 버튼을 클릭
  *  3.입력한 회원정보가 데이터베이스에 저장되고 화면은 메인 페이지로 이동.
     순서
  *  1.데이터베이스 테이블 생성 및 VO 생성
      1)Oracle
      2)MySQL
      3)VO생성
     2.MemberMapper.xml 추가
      1)insert 쿼리문 테스트 및 관리자 아이디 만들기
      2)mapper.xml 작성
     3.MemberMapper.java 인터페이스 추가
     ------------------- 다음 포스팅 ----------------------------------
     4.Mapper에 추가한 쿼리문 테스트 (MemberMapperTests.java)
     5.MemberService.java 추가
     6.MemberController.java 회원가입 메서드 추가
     7.join.jsp
     8.테스트
     9.정리  
  */

  /**정리(지금까지 작성한 문서들은 전체적인 흐름에서 어떤역할을 하는지 어떤흐름을 거치는지 정리)
   
   * views/member/join.jsp
     회원가입 필요한 데이터 입력후 '가입하기' 버튼을 클릭
                        |
                        |
   * com.vam.controller.MemberController.java
     joinPost(memberVO member) 실행
     Memberservice.memberjoin(member) 메서드 호출(회원가입) <-- com.vam.service.MemberService.java
     "redirect/main"으로 리넡(메인페이지로 이동)                 Membermapper.memberJoin(member) 메서드 호출
                        |                                                     |
                        |                                                     |
   * Views/main.jsp                                            com.vam.mapper.MemberMapper.java
     회원가입 완료 후 메인페이지로 리다이렉트 이동                 memberJoin(MemberVO member) 호출
                                                                              |                                                                            
                                                                              |
                                                               Resource/com/sjb/mapper/MemberMapper.xml
                                                               Id = "memberJoin" 실행
                                                                              |
                                                                              |
                                                                         데이터 베이스
                                                                        쿼리 명령 실행     
   */

   /**아이디 중복 검사
    * 1.회원가입페이지(join.jsp)에서 가입하고자 하는 아이디를 입력한다.
    * 2.해당 아이디가 이미 가입된 경우 아이디 입력란 안에 빨간색 경고표시가, 가입된 아이디가 없을 경우 초록생 경고 표시
      순서
    * 1.<span>태그 추가(+css)
      2.아이디 중복검사 메서드 작성 및 테스트(Javascript)
      3.ajax 작성
      4.controller 작성
      5.mapper / service 작성
         5-1 mapper 작성 및 테스트
         5-2 service 작성
      6.ajax success 작성
         6-1 success 코드 추가 및 테스트
         6-2 success 내용 추가
      7.최종 테스트
      8.정리
    */

    /**정리(아이디 중복 검사)
      
     * views/join.jsp
       가입할 아이디 입력
       반환 결과 따른 span 태그 출력
     * com/vam/controller/MemberController.java <----------------------> com/vam/service/MemberService.java
       memberIdChkPOST() 실행                                              IdCheck() 실행
       int결과 수신 받은뒤 그 결과 따른 String데이터를 join.jsp로 반환        int데이터 수신 받은 뒤 controller로 반환
                                                                                       |
                                                                                       |
                                                                         com/vam/mapper/MemberMapper.java
                                                                           IdCheck() 실행
                                                                           int데이터 수신 받은뒤 service로 반환
                                                                                       |
                                                                                       |
                                                                         MemberMapper.xml
                                                                           IdCheck() 실행하여 데이터베이스로부터 쿼리분 요청
                                                                           데이터베이스로부터 결과값 받은 int형 데이터 Mapper.java로 반환                             
     */

     /**인증번호 이메일 전송(1)
      * 입력란에 이메일을 입력한 뒤 [인증번호 전송]을 클릭을 하면 [인증번호 입력란]이 흰색으로 변경됨과 동시에 입력이 가능하고,
      * 인증번호가 입력한 이메일로 전송된다. 이메일로 전송된 인증번호를 [인증번호 입력란]에 입력을 해서 일치할 경우 '일치합니다.'
      * 란 초록색 글이 뜨고, 일치하지 않을 시 '일치하지 않는다.'는 빨간색 글을 뜨도록 하는 것이 목표이다.

        이번 글에서는 다음의 두가지를 목표로 한다.
      * 첫째, 이메일 전송이 가능하도록 기본적인 환경을 세팅.
      * 둘째, View(회원가입페이지)에서 입력한 데이터(이메일 주소)를 Controller(MemberController)로 전송.

        순서 
      * 1.이메일 전송 환경 세팅
      * 2.인증번호 입력한 색상 변경 및 disabled 속성 추가
      * 3.이메일 전송 메서드 추가(자바스크립트)
      * 4.Controller 메서드 추가
      * 5.테스트
      */

    /**인증번호 이메일 전송(2)
     * 목표
     * 1.인증번호(난수) 생성 : 인증번호로서 숫자 6자리를 사용할것이고, 이를 위해서 JAVA에서 제공하는 Random 객체를 사용할것.
                              '자바 난수 생성'과 같은 키워드를 검색하시면 'for문을 이용한 난수 생성', '문자를 포함한 난수 생성'등
                              여러가지 방법이 검색됨. 
     
     * 2.인증번호 이메일 전송
     * 3.인증번호 뷰(회원가입 페이지) 전송
     * 
     */

     /**인증번호 이메일 전송(3)
      * 목표
      * 이번 포스팅에선 인증번호가 뷰와 이메일로 정상적으로 전송되었을 때 입력란에 입력이 가능하게 변경되도록 할 것이다.
        그리고 인증번호 입력란에 입력된 인증번호와 이메일로 전송된 인증번호의 일치 여부에 따라서 그에 맞는 경고글이 뜨도록 하는 기능을 추가.
      * 간단하게 기능 구현만을 목표로 하기 때문에 사용자가 입력한 인증번호와 이메일로 전송된 인증번호를 비교하는 기능을 스크립트로 구현
        이러한 방식은 변수를 선언하여 할당하든 태그를 만들어 태그에 저장을 하든 이메일로 전송한 인증버호를 view에 저장하여 진행되게 한다.
        이럴 경우 사용자가 html, script코드를 볼 수 있다면 인증번호가 노출되는 보안적 문제가 생기게 된다.
        따라서 서버와 송수신을 통해서 해당 기능을 사용하는 것이 좋다고 생각.
      * 순서
        1.인증번호 입력란 변환 기능
        2.인증번호 일치여부 검사 기능
        3.테스트  
      */

      /**로그인 기능 구현의 전체적인 방향
       * 1.아이디, 비번 입력 후 서버 제출
       * 2.DB 요청하여 아이디, 비번 일치 여부 확인
       * 3.일치 시 메인 페이지 이동
       * 4.불일치 시 로그인 페이지 이동
         순서
       * 1.로그인 페이지(login.jsp) 아이디, 비번 전송
       * 2.로그인 처리 메서드 작성(MemberController.java)        
       */

       /**로그인 기능 구현 (페이지 데이터 처리)
        * 저번 포스팅에서는 로그인 서버에 로그인 메서드를 작성하였고 성공, 실패 상황에 따라서 데이터를 
          담아 각 상황에 맞는 페이지로 이동하게 하였다. 이번 포스팅에서는 전달받은 데이터를 활용하여 각 상황에 맞게
          페이지에 로그인, 회원가입 버튼이 사라지고 로그인한 회원의 정보가 뜨는 것이고, 로그인 실패의 경우는 
          로그인 페이지에 로그인에 실패했다는 문구가 뜨도록 하는 것이다.

           코드가 번잡해보이는 것을 피하기 위해서 저는 JSTL을 사용할 것입니다. JSTL에 무엇인지, 
           어떻게 사용하는지 모르시는 분들은 구글링을 통해 찾아보시면 됩니다. 
        */

      /**
       * 우리는 비밀번호를 데이터베이스에 저장하고 있다. 데이터베이스 자체에 보안이 되어 있을 것이지만 만약 뚫리게 된다면
         비밀번호가 무방비하게 노출된다는 문제점이 있다. 이러한 문제점을 보완하기 위해 비밀번호가 노출이 되더라도 
         알아볼 수 없도록 암호화 하는 방법이 있을 것이다. 비밀번호를 인코딩(암호화) 해주고 사용자가 제출한 비밀번호와
         데이터베이스에 저장된 인코딩 된 비밀번호가 일치하는지 확인해주는 메서드를 제공해주는 클래스가 바로 BCryptPasswordEncoder
        
        -BCryptPasswordEncoder 란?
          스프링 시큐리티 프레임워크에서 제공하는 클래스 중 하나로 비밀번호를 암호화하는 데 사용할 수 있는 메서드를 가진 클래스이다.
            -스프링 시큐리티 : 자바 서버 개발을 위해 필요로 한 인증, 권한 부여 및 기타 보안 기능을 제공하는 프레임워크(클래스와 인터페이스 모임)
            -BCryptPasswordEndoder 는 해싱 함수(BCrypt hashiing function)를 사용해서 비밀번호를 인코딩해주는 메서드와 사용자의 의해 제출된 비밀번호
             와 저장소에 저장되어 있는 비밀번호의 일치 여부를 확인해주는 메서드를 제공한다.
            -PasswordEncoder 인터페이스를 구현한 클래스이다.
            -생성자의 인자 값(version, strength, SecureRandom instance)을 통해 해시의 강도를 조절가능
          
          BCryptPasswordEncoder는 위에서 언급했듯이 비밀번호를 암호화하는 데 사용할 수 있는 메서드를 제공한다.
          기본적으로 웹 개발함에 있어서 사용자의 비밀번호를 데이터베이스에 저장하게 된다. 허가되지 않은 사용자가 접근하지 못하도록 기본적인
          보안이 되어 있을 것이다. 하지만 기본적 보안이 되어 있더라도, 만약 그 보안이 뚫리게 되면 비밀번호 데이터는 무방비하게 노출된다.
          이런 경우를 대비해 BCryptPasswordEncoder에서 제공하는 메서드를 활용하여 비밀번호를 암호화 함으로써 비밀번호 데이터가 노출되더라도 
          확인하기 어렵도록 만들어 줄 수 있다.
          
        -메서드 구성
          BCryptPasswordEncoder 는 스프링 시큐리티 5.4.2부터는 3개의 메서드, 그 이전 버전은 2개의 메서드를 가진다.
          공통적으로 encode(), matchers() 메서드에 upgradeEncoding() 메서드가 추가되었다.

          1.encode
            -패스워드를 암호화해주는 메서드이다. encode() 메서드는 8바이트로 결합된 해쉬, 랜덤하게 생성된 솔트를 지원
            -매개변수는 java.lang.CharSequence 타입의 데이터를 입력해주면 된다.
            -반환 타입은 String 타입이다.
            -똑같은 비밀번호를 해당 메서드를 통하여 인코딩하더라도 매번 다른 인코딩 된 문자열을 반환한다.
          2.matchers
            -제출된 인코딩 되지 않은 패스워드(일치 여부를 확인하고자 하는 패스워드)와 인코딩 된 패스워드의 일치 여부를 확인해준다.  
            -첫 번째 매개변수는 일치 여부를 확인하고자 하는 인코딩 되지 않은 패스워드를  두 번째 매개변수는 인코딩 된 패스워드를 입력합니다.
          3.upgradeEncoding
            -더 나은 보안을 위해서 인코딩 된 암호를 다시 한번 더 인코딩해야 하는 경우에 사용합니다.
            -매개변수는 인코딩 필요 여부를 확인하고자 하는 인코딩 된 패스워드(String 타입)를 입력한다.
            -반환 타입은 인코딩이 필요한 경우 true를, 필요하지 않은 경우는 false를 입력한다.
            -encde() 메서드를 통해서 암호화된 패스워드들은 upgradeEncoding()을 사용했을 때 모두 기본적으로 false를 반환
            -따라서 개인적으로 생각해보았을때 해당 메서드는 오버라이딩하여 더 강력한 해시를 해야 할지의 기준을 정한 뒤 처리하여 활용할 수 있을 거 같다.

          두 번의 포스팅에 걸쳐서 회원가입 메서드와, 로그인 메서드에 BCry 클래스의 메서드를 적용,
          회원가입 메서드에 적용하면 인코딩 된 비밀번호가 데이터베이스에 저장될 것이다. 그리고 로그인 메서드에 적용하면
          홈페이지 사용자가 제출한 비밀번호와 데이터베이스에 저장된 인코딩 된 비밀번호가 일치하는지를 확인할 수 있게 될 것이다.     
        
        -사용방법
          스프링 시큐리티의 클래스 중 하나이기 때문에 스프링 시큐리티 라이브러리 추가와 기본적 설정이 필요
          1.스프링 시큐리티 pom.xml 추가
          2.스프링 시큐리티 기본 설정(web.xml 설정, security-context.xml파일 추가 및 BCryptPasswordEncoder 빈 등록)

        -회원가입 메서드 적용
          회원가입 메서드를 수정한다. 기존의 코드의 흐름은 사용자가 작성한 회원가입 정보를 MemberVO 클래스 타입의 member를 통해
          데이터를 받아온다. 회원의 정보가 담긴 member를 매개변수로 한 memberJoin() 메서드를 호출하게되고 이를 통해 BOOK_MEMBER
          테이블에 데이터를 insert 하는 쿼리문이 실행된다.

          -회원정보가 담긴 member -> memberJoin()을 호출하여 회원가입 쿼리 실행
              (Controller -> Service -> DAO -> DB -> DAO -> Service -> Controller)

          우리가 하고자 하는 바는 회원의 정보가 등록될 때 회원의 비밀번호를 그대로 등록하는 것이 아니라
          비밀번호를 사람이 알아볼 수 없는 형태의 문자열로 인코딩을 한 후 저장하고자 한다. 따라서 우리는 
          member객체에서 비밀번호를 꺼낸 뒤, 비밀번호를 member객체에 다시 저장 한 뒤 memberJoin() 메서드를
          실행하여 회원정보를 등록하는 쿼리문을 실행한다.
          
          -회원정보가 담긴 member-> member에 저장된 비밀번호를 꺼냄 -> encode() 메서드를 통해 꺼낸 비밀번호 인코딩
              -> 인코딩 된 비밀번호를 member 객체에 다시 저장 -> memberJoin()을 호출하여 회원가입 쿼리 실행

        -로그인 메서드 적용
          memberLogin(member) 호출하여 반환받은 정보를 lvo 변수에 저장 -> (lvo == null) 작성
            true(lvo가 null인 경우) - 로그인 실패
              -> 리플렉션에 실패를 의미하는 데이터 저장
              -> 로그인 페이지 리다이렉트
            false(lvo가 null이 아닌 경우) - 로그인 성공 
              -> 세션에 사용자의 정보 저장
              -> 메인 페이지로 리다이렉트        
           여기서 가장 핵심은 memberLogin()메서드 입니다. 해당 메서드를 통해 select 쿼리가 실행이 되는데,
           사용자로 부터 제출받은 아이디와 비밀번호가 일치하는 사용자를 찾게 되면 해당 사용자의 정보를 반환하게 되고, 
           일치하는 사용자를 찾지 못하면 null을 반환하게 됩니다.

        -새로 작성할 코드의 흐름
          기존의 코드 경우 memberLogin() 메서드를 호출하여 쿼리문을 실행하기 위해서 사용자가 제출한 아이디, 비밀번호 데이터를 넘겨줌
          하지만 현재 데이터베이스에 저장된 비밀번호는 인코딩 되 데이터이다. 
          따라서 아무리 사용자가 올바른 아이디와 비밀번호를 제출하더라도 memberLogin() 메서드는 null을 반환할 것이다.

          데이터베이스 자체에서 인코딩된 비밀번호와 사용자가 제출한 비밀번호가 일치하는지를 판단해준다면 좋겠지만 이는 불가능하다.
          그렇기 때문에 데이터베이스로부터 사용자의 비밀번호를 꺼내와서 BCryptPasswordEncoder 클래스의 matchers() 메서드를 활용하여 사용자에
          의해 제출된 비밀번호와 일치 여부를 확인해야 한다. 일치 여부에 따라 로그인 성공 시 실행되어야 할 코드를 적용하던지, 로그인 실패 시
          실행되어야 할 코드를 적용해야 할 것이다. 따라서 아래와 같은 흐름으로 코드가 진행되도록 설계하였다.
            
            회원의 정보를 반환하는 쿼리문 실행(사용자의 아이디를 조건으로 함)
            ->회원의 정보가 null인지판단
              null인 경우 - 로그인 실패
                ->로그인 실패 실행 코드
              null이 아닌 경우
                ->matchers() 문을 통해 데이터베이스 저장된 비밀번호와 제출된 비밀번호 일치 여부 확인
                  (true) true인 경우 - 비밀번호 일치
                    로그인 성공 실행 코드
                  (false) false인 경우 - 비밀번호 불일치
                    로그인 실패 실행 코드    
       */ 

       /**로그아웃 기능 구현(메인페이지)
        * 메인페이지에 로그인 성공 시 등장하는 div태그에 로그아웃 버튼을 제작하고, 해당 메서드를 제작하자.
          진행 순서는 view에 버튼 태그에 및 서버 측 로그아웃 메서드를 요청하는 js를 작성한 뒤, 서버 측 로그아웃 기능 실행 메서드 작성
        */

        /**gnb(비동기 로그아웃 버튼)
         * gnb영역에서 로그인한 상황에서 나타나는 로그아웃 버튼의 기능 구현을 목표로 한다.
           저번 포스팅에서 구현한 로그아웃 버튼과 같이 세션을 제거하는 것이 핵심이다.
           하지만 이번 포스팅에선 세션 제거를 요청하는 방식을 비동기 방식으로 구현하고자 한다.(화면 이동 없이 로그아웃 기능 실행)
            
         *순서
          1.전체흐름
          2.Javascript 처리
          3.서버 메서드 작성(MemberController.java)
          4.테스트
          
          *전체흐름
          -저번 포스팅에서 구현했던 로그아웃 메서드의 경우 메서드 작업이 완료된 뒤 지정된 특정 화면으로만 이동되도록 하였다.
            로그아웃 버튼의 경우 거의 모든 페이지에 삽입되어야 하는데, 이럴경우 페이지가 많아지면 그 페이지 수만큼 그에 맞는 
            로그아웃 메서드를 작성해야 한다.
            하지만 이번에 구현하고자 로그아웃은 특정 화면으로 이동없이 현 페이지가 새로고침 됨으로써 화면의 구성이 바뀌도록 하는 것이 목표
            전체적인 흐름은 로그아웃 버튼을 자바스크립트를 통해서 동작하게 만들고 ajax를 통해서 서버에 로그아웃 메서드를 요청하도록 할 것.
            로그아웃 메서드가 수행이 완료되면 다른 화면으로 이동 없이 요청한 페이지에서 새로고침 되어 로그아웃 되었을 때의 화면 구성으로
            변환 되도록 작성할 것이다.

            로그 아웃 버튼 클릭 => javascript 버튼 메서드 작동 => ajax 통해 로그아웃 요청 => 서버 로그아웃 수행 => 화면 이동없이 새로고침 통해 화면 변환
         */

         /**댓글
          * 목표
            1.개요
            2.DTO클래스
            3.Mapper 메서드
            4.Service 메서드
            5.Controller

            (Create)
              -로그인한 회원이 '상품 상세 페이지'로 이동했을 때 "댓글 등록" 버튼이 보인다.
              -댓글 등록 버튼을 누르면 댓글을 작성할 수 있는 팝업창이 뜬다.
              -팝업창에서는 평점을 select 방식으로 선택할 수 있고, 댓글은 <textarea>에 작성할 수 있다.
              -다 작성 후 '등록' 버튼을 누르면 DB에 댓글 등록이 완료된다.
              -댓글 등록 동작 과정에서 상품 테이블(vam_book)의 평점(평균 평점)이 최신화 된다.
              -댓글이 등록되면 팝업창이 닫히고 '상품 상세 페이지'에는 등록한 댓글을 볼 수 있다.
          */